# zalt-html
Zalt html is a PHP library for easy Html use and creation, with minimal dependencies on external libraries.

The library consist of three sub-packages:

1. **Html** The (main) Zalt-Html code makes it easy to generate HTML output using objects.
2. **Snippets** Objects that combine HTML generation with business logic code and limited routing.
3. **SnippetsLoader** Objects that load the snippets and take care of dependency injection, etc...
4. **SnippetsHandler** MiddelWare RequestHandlerInterface classes that can be used to load and run SnippetActions
5. **SnippetsActions** Combinations of Snippet (classes) and options for Snippets to set  

## Html

The Html package is meant for the easy creation, extension and changing of HTML objects. 

```php
$div = Html::create('div', ['class' => 'my-div']);
$div->img('hello.png', ['style' => 'float: right;']);
$p = $div->p('This will be <HTML>. ', ['data-xyz' => 'whatever']);
$p->raw('This <b>bold</>.');
echo $div->render();
```

Will output something like:

```html
<div class="my-div"><img src="/images/hello.png" width="20" height="20" style="float: right;"/>
    <p data-xyz="whatever">
        This will be &amp;lt;HTML&amp;gt;. This <b>bold</b>. 
    </p>
</div>
```

The package has some knowledge of HTML, as demonstrated by the automatic adaptation on the image element, but this
is very limited and usually does not get in the way of outputting what you want, as demonstrated by the data-xyz 
attribute of the P element. All text is automatically escaped, except when the Raw object is used. 

The philosophical idea is that as a programmer I know HTMl and do not want to learn a complex object interface that 
limits what I can and cannot do. So the basics for using the HtmlElement objects are:
- Use it as an array or object whatever is convenient at that moment.
- Things appended using a text key are an attribute.
- Things appended using a numeric key or no key are content.
- Append the content child tag``<nonExisitingFunction/>``HtmlElement by calling``$htmlElement->nonExisitingFunction()``.


## Snippets

Snippets are reusable html content with a simple business logic:

1. Check for HtmlOutput and if it is there, add the HTML to the output.
2. Without HTML check for a ``ResponseInterface`` object and return that if it exists.
3. Without HTML or a Response object, check for a Redirect Route, Return as ``RedirectResponse`` if that exists.
4. Go back to step 1 for the next snippet if any.
5. After the last snippet, combine all the HTML output in a ``HtmlResponse``.

This limited logic allows for a completely responsive application. The snippets used depend (of course) on the route
used by the user.

## SnippetsLoader

Snippets use objects and scalar options to determine the output. Some of these objects depend on the request object 
generated by middleware in Psr standard applications (e.g. the request object itself). So a standard ServiceManager 
usually does not contain all the objects needed by snippets. 

So we use a specialized **SnippetLoader** with an ``addConstructorVariable`` function that allows the addition 
of extra objects in addition to the existing ServiceManager classes. The SnippetLoader uses a constructor dependency
resolver that looks at the object constructor to determine the required object for initiation.

To pass scalars values (e.g. ``$createData = true``) to a snippet we use a SnippetOption containing an array of 
values. This functionality was created for scalars, but this method *can also be used to pass extra objects* to the 
snippet! SnippetOptions are usually passed as the first object in the snippet constructor. The object is not stored 
in the snippet but is evaluated using the ``setSnippetOptions()`` function. 


## SnippetsHandler


## SnippetsActions